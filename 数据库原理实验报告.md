# 数据库原理实验报告 

| 项目名称 | 网上书店（云书店管理系统） |
| :------: | :------------------------: |
|   姓名   |           熊宇祺           |
|   学号   |          09023112          |

> **实验环境**：
>
> |  Python 3.11.7  |
> | :-------------: |
> |  **Flask 2.3**  |
> | **SQLAlchemy**  |
> |   **SQLite**    |
> |    **MySQL**    |
> | **Bootstrap 5** |

---



## 1. 实验场景介绍

### 1.1 应用背景

​	随着电子商务的普及，传统的实体书店正面临数字化转型的挑战。开发一套高效、稳定的网上书店系统（Online Bookstore System）能够帮助书店突破地理限制，实现24小时不间断营业，同时通过数据分析（如销量排行）为用户提供更精准的购书指引。

### 1.2 场景描述

​	本实验构建了一个名为“云书店”的B/S架构在线图书销售平台。该系统模拟了真实电商环境中的核心闭环，连接了普通消费者与后台管理数据。主要涵盖以下业务逻辑：

1. **用户中心**：
   - **身份管理**：用户必须注册并登录后才能进行敏感操作（如下单、查看历史订单），系统需保障用户密码的安全存储（哈希加密）。
   - **个人足迹**：系统记录用户的消费历史，提供订单追踪功能。
2. **商品展示与检索**：
   - **多维分类**：图书具有层级结构（如：计算机 -> 编程语言 -> Python），用户可通过分类树快速定位感兴趣的领域。
   - **组合筛选**：支持按“出版社”、“出版年份”进行过滤，并支持按“书名/作者”进行模糊检索。
   - **动态展示**：首页根据销量自动生成“热门畅销榜”，引导用户消费。
3. **交易处理系统**：
   - **购物车**：用户可将多本图书加入购物车，随时调整数量，通过购物车，可以实时查看这笔订单的情况（买了哪些商品，总价格多少）。
   - **原子化下单**：当用户点击结算时，系统必须在数据库层面保证“库存扣减”与“订单生成”的一致性，防止超卖现象。

---





## 2. 数据库设计

### 2.1 数据流图 

系统主要包含三个核心数据流向：

1. **图书检索流**：

   - **输入**：用户在前端输入的“关键词”、“分类选择”或“筛选条件”。

   - **处理**：后端接收参数，组合查询条件，在 Book 表中进行匹配，并关联 Category 表获取分类名称。

   - **输出**：符合条件的图书列表数据（JSON格式），包含封面、价格、作者等信息。

     ![image-20251227142107259](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227142107259.png)

   

   

   

   

   

2. **交易执行流**：

   - **输入**：用户提交的购物车清单（图书ID列表及数量）。

   - **处理**：开启数据库事务。查询 Book 表检查库存。更新 Book 表（库存 - N，销量 + N）。写入 Order 表生成主订单。写入 OrderItem 表生成多条明细。

   - **输出**：交易成功/失败状态及订单号。

     ![image-20251227142214953](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227142214953.png)

















3. **历史追溯流**：

   - **输入**：当前登录用户的 User ID。

   - **处理**：在 Order 表中查找该用户所有记录，并级联查询 OrderItem 获取详情。

   - **输出**：按时间倒序排列的完整订单历史。

     ![image-20251227142258029](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227142258029.png)
     
     

### 2.2 概念模式 E-R 图设计

在本项目的数据库概念模型中，包含 4 个核心实体（实体集）和 1 个关联实体（弱实体）。

#### **2.2.1 实体定义：**

1. **用户 (Customer)**：注册并登录系统的终端用户。
   - 关键属性：用户ID、用户名、密码哈希、邮箱。
2. **图书 (Book)：系统中售卖的商品。**
   - 关键属性：图书ID、书名、作者、价格、折扣、库存、销量、出版社、出版日期、页数、封面图、分类ID。
3. **分类 (Category)**：图书的类别结构，具有层级关系（如：计算机 -> 编程语言）。
   - 关键属性：分类ID、名称、父分类ID。
4. **订单 (Order)**：用户的一次购买行为记录。
   - 关键属性：订单ID、总金额、创建时间。
5. **订单明细 (OrderItem)**：订单与图书之间的关联实体，用于解决“一个订单包含多本书”且“一本书可以在多个订单中”的多对多关系。
   - 关键属性：明细ID、购买数量、购买时单价，订单ID，图书ID。
#### **2.2.2 实体间关系定义：**

1. **用户（Customer）— 订单（Order）**  
   - **关系类型**：1 : N  
   - **关系名**：下订单（places）  
   - **说明**：一个用户可以创建多个订单，但每个订单只能属于一个用户。
2. **订单（Order）— 订单明细（OrderItem）**  
   - **关系类型**：1 : N  
   - **关系名**：拥有（includes）  
   - **说明**：一个订单由若干条订单明细组成，订单删除时，其对应的订单明细应被级联删除。
3. **图书（Book）— 订单明细（OrderItem）**  
   - **关系类型**：1 : N  
   - **关系名**：被列入（listed in）  
   - **说明**：一本图书可以出现在多个订单中，每条订单明细只对应一本图书。
4. **分类（Category）— 图书（Book）**  
   - **关系类型**：1 : N  
   - **关系名**：包含（contains）  
   - **说明**：一个分类下可以包含多本图书，每本图书只属于一个最底层分类。
5. **分类（Category）— 分类（Category，自关联）**  
   - **关系类型**：1 : N  
   - **关系名**：父子关系（is parent of）  
   - **说明**：分类之间存在层级结构，一个父分类可以包含多个子分类，而子分类只能有一个父分类。

> 本系统中，**订单（Order）** 与 **图书（Book）** 在业务逻辑上属于多对多（M : N）关系。  为满足关系数据库范式要求，引入 **订单明细（OrderItem）** 作为关联实体（弱实体），  将多对多关系拆分为两个一对多关系：

> - 订单（Order） → 订单明细（OrderItem）
> - 图书（Book） → 订单明细（OrderItem）

> - **订单明细（OrderItem）** 的存在依赖于订单和图书，其主键通常由系统生成的明细ID或由（订单ID，图书ID）组合确定。

 #### 2.2.3 **概念模式 E-R 图：**

![image-20251227143535959](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227143535959.png)





### 2.3 数据模式设计 (Schema)

基于 models.py 的定义，系统建立了以下 5 张数据表：

#### (1) 分类表 category (自关联)

用于存储图书的层级分类结构。
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| **id** | Integer | **PK**, Auto Inc | 分类唯一标识 |
| **name** | Varchar(50) | Not Null | 分类名称（如“计算机”） |
| **parent_id** | Integer | **FK** (category.id) | 父分类ID，根节点为NULL |

**对应的MySQL语句：**

```mysql
CREATE TABLE category (
    id INT AUTO_INCREMENT PRIMARY KEY,  
    name VARCHAR(50) NOT NULL,          
    parent_id INT DEFAULT NULL,         
    CONSTRAINT fk_category_parent       
        FOREIGN KEY (parent_id)             
        REFERENCES category(id)             
        ON DELETE SET NULL                  
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

- `AUTO_INCREMENT`：实现分类 ID 自增
- `parent_id` 自关联外键：表示分类的层级结构

- `ON DELETE SET NULL`：删除父分类时，子分类不会被删除，而是变成根分类

  

#### (2) 图书表 book

核心数据表，存储图书详情及库存状态。
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| **id** | Integer | **PK**, Auto Inc | 图书唯一标识 |
| **title** | Varchar(200)| Not Null | 书名 |
| **category_id**| Integer | **FK** (category.id) | 外键，关联分类表 |
| **price** | Float | Not Null | 定价 |
| **sale_price** | Float | - | 实际售价 |
| **stock** | Integer | Default 100 | **库存量**（关键字段） |
| **sales_count**| Integer | Index | **销量**（用于排行） |
| **publisher** | Varchar(100)| Index | 出版社（用于筛选） |
| **pub_date** | Date | Index | 出版日期 |
| **image_url** | Varchar(500)| - | 封面图片路径 |

**对应的MySQL语句：**

```mysql
CREATE TABLE book (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author VARCHAR(100) NOT NULL,
    isbn VARCHAR(20) UNIQUE,            
    price FLOAT NOT NULL,
    sale_price FLOAT DEFAULT NULL,
    stock INT DEFAULT 100,              
    sales_count INT DEFAULT 0,          
    publisher VARCHAR(100),             
    pub_date DATE,

    pages INT,
    language VARCHAR(20),
    image_url VARCHAR(500),             

    category_id INT NOT NULL,

    CONSTRAINT fk_book_category         
        FOREIGN KEY (category_id)       如果这个分类下有书籍，不能删除该分类
        REFERENCES category(id)
        ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```



#### (3) 用户表 customer

记录用户信息，方便登录。

| 字段名            | 类型         | 约束             | 描述               |
| ----------------- | ------------ | ---------------- | ------------------ |
| **id**            | Integer      | **PK**, Auto Inc | 用户ID             |
| **username**      | Varchar(80)  | Unique, Not Null | 登录用户名         |
| **password_hash** | Varchar(128) | Not Null         | 加密后的密码散列值 |
| **email**         | VARCHAR(120) | UNIQUE           | 邮件               |

**对应的MySQL语句：**

```mysql
CREATE TABLE customer (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(80) NOT NULL UNIQUE,
    email VARCHAR(120) UNIQUE,
    password_hash VARCHAR(128)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```



#### (4) 订单表 orders

记录交易的宏观信息。
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| **id** | Integer | **PK**, Auto Inc | 订单号 |
| **customer_id**| Integer | **FK** (customer.id) | 外键，下单用户 |
| **total_amount**| Float | - | 订单总金额 |
| **created_at** | DateTime | Default Now | 下单时间 |

**对应的MySQL语句：**

```mysql
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    total_amount FLOAT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id)
        REFERENCES customer(id)
        ON DELETE SET NULL         
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```



#### (5) 订单明细表 order_item

连接订单与图书的桥梁表。
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| **id** | Integer | **PK**, Auto Inc | 条目ID |
| **order_id** | Integer | **FK** (orders.id) | 所属订单 |
| **book_id** | Integer | **FK** (book.id) | 购买的图书 |
| **quantity** | Integer | Not Null | 购买数量 |
| **price** | Float | Not Null | 购买时的单价（快照） |

**对应的MySQL语句：**

```mysql
CREATE TABLE order_item (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    book_id INT,
    quantity INT,
    price FLOAT,    

    CONSTRAINT fk_item_order
        FOREIGN KEY (order_id)  
        REFERENCES orders(id)
        ON DELETE CASCADE,      

    CONSTRAINT fk_item_book
        FOREIGN KEY (book_id)   
        REFERENCES book(id)
        ON DELETE RESTRICT      
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

------



## 3. 系统功能介绍与效果展现

本部分展示系统主要业务功能及其对应的数据库操作效果。

### 3.1 用户注册与登录

- **功能描述**：新用户输入用户名和密码进行注册，系统检查用户名唯一性后存入数据库。登录时验证哈希密码。

- **对应的MySQL语句**：

  ```mysql
  -- 1. 注册：检查用户名是否已存在
  SELECT 1 
  FROM customer 
  WHERE username = 'test_user' 
  LIMIT 1;
  
  -- 2. 注册：如果不存在，插入新用户 (密码为哈希值)
  INSERT INTO customer (username, password_hash) 
  VALUES ('test_user', 'scrypt:32768:8:1$...');
  
  -- 3. 登录：根据用户名查询用户信息以验证密码
  SELECT id, username, password_hash 
  FROM customer 
  WHERE username = 'admin' 
  LIMIT 1;
  ```

- **界面截图**：

  > **点击“登录/注册”按钮弹出的模态框界面**

  ![image-20251227150011576](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227150011576.png)

  > **登录成功后，顶部导航栏显示“你好, (用户名)”的状态]**

  ![image-20251227150156868](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227150156868.png)



### 3.2 首页：销量排行榜与分类导航

- **功能描述**：**畅销榜**：页面顶部横向滚动条自动展示销量最高的前10本书。**分类树**：左侧侧边栏展示从数据库递归查询出的父子分类结构。

- **对应的MySQL语句**：

  ```mysql
  -- 1. 畅销榜：按销量降序查询前10名
  SELECT id, title, author, sale_price, image_url, sales_count
  FROM book 
  ORDER BY sales_count DESC 
  LIMIT 10;
  
  -- 2. 分类导航：查询所有根分类（用于构建分类树）
  SELECT id, name 
  FROM category 
  WHERE parent_id IS NULL;
  
  -- (ORM会自动懒加载子分类，底层执行类似如下语句)
  -- SELECT * FROM category WHERE parent_id = ?;
  ```

- **界面截图**：

  > **首页顶部“热门畅销书架”和左侧“分类侧边栏”的界面**

  ![image-20251227150331377](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227150331377.png)

  ![image-20251227150438954](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227150438954.png)



### 3.3 图书列表：多维筛选与搜索

- **功能描述**：用户可以通过顶部搜索框输入关键词，或通过下拉菜单筛选“出版社”和“年份”。系统以网格形式展示图书封面、书名、价格。

- **对应的MySQL语句**:

  > *(假设场景：搜索关键词 "Python"，年份 "2023"，显示第 1 页)*

  ```mysql
  SELECT * 
  FROM book 
  WHERE 
      -- 关键词模糊匹配 (书名 OR 作者)
      (title LIKE '%Python%' OR author LIKE '%Python%')
      -- 年份筛选
      AND YEAR(pub_date) = 2023
      -- (可选) 出版社筛选
      -- AND publisher = '机械工业出版社'
  ORDER BY id ASC
  -- 分页：每页12条 (OFFSET = (page-1)*12)
  LIMIT 12 OFFSET 0;
  ```
- **界面截图**：

  > **在搜索框输入“Python”的搜索结果界面]**
  
  ![image-20251227150804089](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227150804089.png)
  
  > **在左侧分类侧边栏选中<文学 - 中国当代>的搜索结果界面**
  
  ![image-20251227151000978](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227151000978.png)
  
  > **在左侧分类侧边栏选中<计算机 - 编程语言 - 所有出版社- 2023>的搜索结果**
  
  ![image-20251227151051643](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227151051643.png)



### 3.4 购物车与下单结算

- **功能描述**：点击“加入购物车”将商品存入本地状态。点击“结算”时，后端执行严格的库存检查。若库存充足，则扣减库存并生成订单；若不足则回滚。

- **对应的MySQL语句**:

  > *假设用户 ID=101，购买图书 ID=5，数量=2*

  ```mysql
  START TRANSACTION;
  
  -- 1. 插入订单主记录 (初始金额设为0，获取生成的订单ID)
  INSERT INTO orders (customer_id, total_amount, created_at) 
  VALUES (101, 0, NOW());
  
  -- 假设生成的订单 ID 为 202401
  
  -- 2. 检查并扣减库存 (循环处理购物车中的每本书)
  -- (选读) 锁定行以防止并发冲突
  SELECT stock, sale_price FROM book WHERE id = 5 FOR UPDATE;
  
  -- 如果 stock >= 2，则更新
  UPDATE book 
  SET stock = stock - 2, 
      sales_count = sales_count + 2 
  WHERE id = 5;
  
  -- 3. 插入订单明细
  INSERT INTO order_item (order_id, book_id, quantity, price) 
  VALUES (202401, 5, 2, 89.0);
  
  -- 4. 计算总价并更新订单主表
  UPDATE orders 
  SET total_amount = 178.0 
  WHERE id = 202401;
  
  COMMIT;
  -- 如果中间任何一步出错 (如库存 < 2)，则执行 ROLLBACK;
  ```

- **界面截图**：

  > **打开购物车模态框，显示已选商品和总金额的界面**
  
  ![image-20251227151357241](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227151357241.png)
  
  > **点击结算后，弹出“下单成功”提示**
  
  ![image-20251227151419663](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227151419663.png)



### 3.5 个人订单历史查询

- **功能描述**：用户登录后，点击“我的订单”查看历史购买记录，包含订单号、总价及具体购买了哪些书。

- **对应的MySQL语句**:

  ```mysql
  -- 1. 查询当前用户的所有订单 (按时间倒序)
  SELECT id, total_amount, created_at 
  FROM orders 
  WHERE customer_id = 101 
  ORDER BY created_at DESC;
  
  -- 2. (级联查询) 获取特定订单(如 ID 202401) 的所有书籍明细
  SELECT oi.quantity, oi.price, b.title 
  FROM order_item oi
  JOIN book b ON oi.book_id = b.id
  WHERE oi.order_id = 202401;
  ```


- **界面截图**：

  > **点击“我的订单”后弹出的订单列表界面**

  ![image-20251227151644646](C:\Users\alexa\AppData\Roaming\Typora\typora-user-images\image-20251227151644646.png)

------



## 4. 核心代码

​	本节选取系统中5个最关键的数据库交互逻辑，展示基于python的ORM 代码与底层 MySQL 语句的对应关系。

### 4.1 多条件组合查询与分页

**功能**：实现图书列表的筛选（分类、关键词、出版社、年份）及分页。

- **Python (SQLAlchemy)**:

```python
@app.route('/api/books')
def get_books():
    """
    获取图书列表的API接口
    
    该接口支持分页查询和多种筛选条件，包括分类ID、关键词搜索、出版社和出版年份
    
    参数:
        page (int): 页码，默认为1
        cat_id (int): 分类ID，用于筛选特定分类的图书
        keyword (str): 搜索关键词，用于在书名或作者中搜索
        publisher (str): 出版社名称，用于筛选特定出版社的图书
        year (str): 出版年份，用于筛选特定年份出版的图书
    
    返回:
        JSON: 包含图书列表、总页数、当前页码和总项目数的字典
            - books: 图书对象列表，每个图书对象包含详细信息
            - total_pages: 总页数
            - current_page: 当前页码
            - total_items: 总项目数
    """
    page = request.args.get('page', 1, type=int)
    cat_id = request.args.get('cat_id', type=int)
    keyword = request.args.get('keyword', '')
    publisher = request.args.get('publisher', '')
    year = request.args.get('year', '')
    
    # 构建基础查询对象
    query = Book.query
    # 根据分类ID筛选图书
    # SELECT * FROM book WHERE category_id = ?
    if cat_id: query = query.filter_by(category_id=cat_id)
    # 根据关键词在书名或作者中进行模糊搜索
    # SELECT * FROM book WHERE title LIKE '%keyword%' OR author LIKE '%keyword%'
    if keyword: query = query.filter(Book.title.contains(keyword) | Book.author.contains(keyword))
    # 根据出版社筛选图书
    # SELECT * FROM book WHERE publisher = ?
    if publisher: query = query.filter_by(publisher=publisher)
    # 根据出版年份筛选图书
    # SELECT * FROM book WHERE YEAR(pub_date) = ?
    if year: query = query.filter(extract('year', Book.pub_date) == year)
        
    # 执行分页查询，每页12条记录
    # MySQL等价查询: LIMIT 12 OFFSET ((page-1)*12)
    pagination = query.paginate(page=page, per_page=12, error_out=False) # 改为每页12本，布局更整齐
    
    return jsonify({
        'books': [b.to_dict() for b in pagination.items],
        'total_pages': pagination.pages,
        'current_page': page,
        'total_items': pagination.total
    })
```

- **对应的 MySQL 语句**:

```mysql
SELECT * FROM book 
WHERE 
    category_id = ? 
    AND (title LIKE '%keyword%' OR author LIKE '%keyword%')
    AND publisher = ?
    AND YEAR(pub_date) = ?
LIMIT 12 OFFSET ((page-1) * 12);
```

### 4.2 订单创建与库存扣减（事务处理）

**功能**：原子性地处理下单逻辑，确保数据一致性。

- **Python (SQLAlchemy)**:

```python
@app.route('/api/order', methods=['POST'])
@login_required
def create_order():
    """
    创建订单接口 - 对应的MySQL语句说明
    
    该函数处理用户提交的订单创建请求，验证商品库存，更新库存和销售数据，
    并将订单信息保存到数据库中。如果库存不足或其他异常情况发生，会回滚事务。
    
    主要执行的MySQL语句包括：
    1. 插入订单记录: INSERT INTO orders (customer_id, total_amount, created_at) VALUES (?, ?, NOW())
    2. 查询图书信息: SELECT * FROM books WHERE id = ?
    3. 更新图书库存: UPDATE books SET stock = stock - ?, sales_count = sales_count + ? WHERE id = ?
    4. 插入订单项: INSERT INTO order_items (order_id, book_id, quantity, price) VALUES (?, ?, ?, ?)
    5. 更新订单总金额: UPDATE orders SET total_amount = ? WHERE id = ?
    """
    items = request.json.get('items', [])
    try:
        # 创建新订单记录，初始总金额为0
        # INSERT INTO orders (customer_id, total_amount, created_at) VALUES (?, 0, NOW())
        order = Order(customer_id=current_user.id, total_amount=0)
        db.session.add(order)
        db.session.flush()
        total = 0
        
        # 遍历订单项，验证库存并计算总金额
        for i in items:
            # 根据ID查询图书信息
            # MySQL等价语句: SELECT * FROM books WHERE id = ? LIMIT 1
            book = Book.query.get(i['id'])
            if book.stock < i['qty']: raise Exception(f"{book.title} 库存不足")
            
            # 更新图书库存和销量
            # MySQL等价语句: UPDATE books SET stock = stock - ?, sales_count = sales_count + ? WHERE id = ?
            book.stock -= i['qty']
            book.sales_count += i['qty']
            total += book.sale_price * i['qty']
            
            # 添加订单项记录
            # MySQL等价语句: INSERT INTO order_items (order_id, book_id, quantity, price) VALUES (?, ?, ?, ?)
            db.session.add(OrderItem(order_id=order.id, book_id=book.id, quantity=i['qty'], price=book.sale_price))
        
        # 更新订单总金额
        # MySQL等价语句: UPDATE orders SET total_amount = ? WHERE id = ?
        order.total_amount = total
        db.session.commit()
        return jsonify({'msg': 'OK', 'id': order.id})
    except Exception as e:
        # 发生异常时回滚数据库事务
        # MySQL等价语句: ROLLBACK
        db.session.rollback()
        return jsonify({'error': str(e)}), 400
```

- **对应的 MySQL 语句**:

```mysql
START TRANSACTION;

-- 1. 插入订单头
INSERT INTO orders (customer_id, created_at, total_amount) VALUES (101, NOW(), 0);
SET @order_id = LAST_INSERT_ID();

-- 2. 循环处理每个商品 (假设书籍ID=5, 数量=2)
SELECT stock, sale_price FROM book WHERE id = 5 FOR UPDATE; -- 行锁
-- 如果 stock < 2 则 ROLLBACK

UPDATE book SET stock = stock - 2, sales_count = sales_count + 2 WHERE id = 5;

INSERT INTO order_item (order_id, book_id, quantity, price) 
VALUES (@order_id, 5, 2, 89.0);

-- 更新总价
UPDATE orders SET total_amount = 178.0 WHERE id = @order_id;

COMMIT;
```

### 4.3 销量排行榜查询

**功能**：获取销量最高的10本书。

- **Python (SQLAlchemy)**:

```python
@app.route('/api/rankings')
def get_rankings():
    """
    获取销量排行榜前10的书籍
    
    该函数查询数据库中按销量降序排列的前10本书籍，并将结果转换为字典列表返回
    
    Args:
        无参数
    
    Returns:
        flask.Response: JSON格式的响应，包含销量排行榜前10的书籍信息列表
    """
    # 查询按销量降序排列的前10本书籍
    """
    SELECT * 
    FROM book 
    ORDER BY sales_count DESC 降序
    LIMIT 10;
    """
    books = Book.query.order_by(Book.sales_count.desc()).limit(10).all()
    return jsonify([b.to_dict() for b in books])
```

- **对应的 MySQL 语句**:

```mysql
SELECT * 
FROM book 
ORDER BY sales_count DESC 
LIMIT 10;
```

### 4.4  用户登录

**功能**：处理用户登录请求，验证用户名和密码，如果验证成功则登录用户。

- **Python (SQLAlchemy)**:

```python
@app.route('/api/login', methods=['POST'])
def login():
    """
    用户登录接口
    
    该函数处理用户登录请求，验证用户名和密码，如果验证成功则登录用户
    
    参数:
        无显式参数，从请求体中获取JSON数据，包含username和password字段
    
    返回值:
        成功时返回JSON响应: {'msg': '登录成功', 'user': 用户名}，状态码200
        失败时返回JSON响应: {'error': '失败'}，状态码401
    """
    data = request.json
    # 根据用户名查询用户信息
    # SELECT * FROM customer WHERE username = ? LIMIT 1;
    user = Customer.query.filter_by(username=data['username']).first()

    # 验证用户存在且密码正确后执行登录
    # 验证用户是否存在  
    # SELECT COUNT(*) FROM customer WHERE username = ?;
    # 完整的用户信息查询（用于密码验证）
    # SELECT id, username, password_hash FROM customer WHERE username = ?;
    if user and user.check_password(data['password']):
        login_user(user)
        return jsonify({'msg': '登录成功', 'user': user.username})
    return jsonify({'error': '失败'}), 401
```

- **对应的 MySQL 语句**:

```mysql
SELECT * FROM customer WHERE username = ? LIMIT 1;
SELECT COUNT(*) FROM customer WHERE username = ?;
SELECT id, username, password_hash FROM customer WHERE username = ?;
```



### 4.5  用户注册

**功能**：新用户注册。检查用户名是否已存在，如果不存在则创建新用户并保存到数据库中。

- **Python (SQLAlchemy)**:

```python
@app.route('/api/register', methods=['POST'])
def register():
    """
    用户注册接口
    
    该接口接收POST请求，用于新用户注册。检查用户名是否已存在，
    如果不存在则创建新用户并保存到数据库中。
    
    参数:
        无显式参数，从请求体中获取JSON数据，包含username和password字段
    
    返回:
        Response: JSON格式的响应，包含成功或错误信息
                 - 成功时返回: {'msg': 'OK'}, 状态码200
                 - 用户名已存在时返回: {'error': '已存在'}, 状态码400
    """
    data = request.json
    # 检查用户名是否已存在，如果存在则返回错误信息
    # SELECT * FROM customer WHERE username = ? LIMIT 1;
    if Customer.query.filter_by(username=data['username']).first(): return jsonify({'error': '已存在'}), 400
    user = Customer(username=data['username'])
    user.set_password(data['password'])
    # 如果不存在则插入新用户
    # INSERT INTO customer (username, password_hash) VALUES (?, ?);
    db.session.add(user)
    db.session.commit()
    return jsonify({'msg': 'OK'})
```

- **对应的 MySQL 语句**:

  ```mysql
  SELECT * FROM customer WHERE username = ? LIMIT 1;
  INSERT INTO customer (username, password_hash) VALUES (?, ?);
  ```

  

## 5. 实验总结

本次实验基于 Flask 框架与 ORM 技术，成功实现了一个功能完备的云书店管理系统。

1. **全栈开发体验**：通过整合 Python 后端与 Bootstrap 前端，深刻理解了 B/S 架构中数据从数据库到前端页面的完整流动过程。
2. **数据库设计实践**：实验中设计的五张表涵盖了自关联（分类表）、一对多（用户-订单）和多对多（订单-图书）等多种经典关系，验证了关系型数据库设计的核心理论。
3. **事务的重要性**：在实现下单功能时，我认识到仅有 SQL 语句是不够的，必须通过事务（Transaction）机制来保证“库存”与“订单”数据的一致性，这是电商系统的基石。
4. **ORM 与 SQL 的映射**：通过编写 SQLAlchemy 代码并分析其生成的 SQL 语句，我掌握了如何高效地进行复杂查询（如多条件筛选和分页），同时也意识到了索引优化（如在 publisher 字段建立索引）对查询性能的提升作用。